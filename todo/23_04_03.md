# TODO
## Code
- plot resulting jacobians
- double check again that we are doing everything right with dynamics in KOMO

## Writing
- write abstract
- make clear what are the optimization variables and constraints for each method
- make plots single plots not directly subfigures
- check who is writing the introduction to KOMO
- describe different discretization schemes for scvx and casadi and komo

# IN PROGRESS
## Code
- decrease the constraint violation threshold for KOMO
- add the number of iterations

## Writing

# DONE
## Code
- add number of AuLa Iterations (how often is the Newton Solver called)
  - what about newton iterations
- add number of scvx iterations
  - convex iterations (how often is ecos called)
  - scvx iterations



## Writing
- double check model description
- describe ECOS instead of gurobi

# DISCUSSION
- what about hessian evaluations:
  - number of hessian evaluations for IPopt
    - ipopt uses a log barrier method to approximate a solution fulfilling the KKT conditions
    - as unconstrained solver is damped newton used
    - damped newton uses the hessian to compute step  
    - why is number of lagrangian hessian evaluations equal to number of iterations
  - number of hessian evaluations for KOMO
    - KOMO uses AuLa to calculate a colution fulfilling the KKT conditions#
    - uses newton as well
    - newton uses hessian to compute steps
  - number of hessian evaluations for SCVX
    - SCVX approximates the nonlinear optimization problem as convex in each iteration
    - uses ECOS to solve convex problem
    - 

# BACKLOG
- clean up forked repo mess
- things to improve casadi
  - include scaling
  - tune ipopt
  - generate c code for dynamic functions?
    - try to use generated c code by implementing an ode object in casadi
